mutate(location = case_when((silly == TRUE) ~ imp_loc, (silly == FALSE) ~ location_temp)) %>%
select(-c(chosen_X, chosen_Y, imp_loc, silly, location_temp)) %>%
ungroup() %>%
arrange(dayID, periodID, start)
# Output csv to local file system, arranged by dayID, periodID, and timestamp.
write.csv(df, "~/Desktop/epistemic_analytics/shamya_collab/shamya_collab/datasets/collapsed_AI_classroom_data.csv", row.names = FALSE)
# Unused experimental code for bug fixes and notes
#
# Save end timestamps in another dataset, to join later
# end_of_times <- df["end"]
#
# df <- df %>%
#   select(-end)
# na_df <- df %>%
#   filter(is.na(chosen_X) | is.na(chosen_Y)) %>%
#   select(-c(chosen_X, chosen_Y))
#
# not_na_df <- df %>%
#   filter(!is.na(chosen_X) & !is.na(chosen_Y))
# relocate(periodID, .before = "time_stamp") %>%
# relocate(dayID, .before = "periodID")# %>%
#mutate(time_stamp2 = time_stamp, .after = "time_stamp")
#df_na_locs <- left_join(na_df, df_locations, by = c("dayID", "periodID", "time_stamp" = "start", "time_stamp2" = "end"))
# Code to impute Monitoring class: Fixed location data with last Stopping row's location
# not_fixed_stopping <- df %>%
#   arrange(start) %>%
#   filter(event != "Monitoring class: Fixed" & event != "Stopping")
#
# fixed_stopping <- df %>%
#   arrange(start) %>%
#   filter(event == "Monitoring class: Fixed" | event == "Stopping") %>%
#   mutate()
#
#
# fixed <- which(fixed_stopping["event"] == "Monitoring class: Fixed")
#
# for (i in fixed) {
#   fixed_stopping[i, ]$location <- fixed_stopping[i-1, ]$location
# }
#
# df <- full_join(not_fixed_stopping, fixed_stopping) %>%
#   arrange(start)
# df["location"][is.na(df["location"])] <- "None"
#df["subject"][is.na(df["subject"])] <- "None"
#df["content"][is.na(df["content"])] <- "None"
# Note: There are some teacher positions not included in the location dataset.
library(readr)
df <- read_csv("code/collapsed_AI_classroom_data.csv")
library(readr)
df <- read_csv("./datasets/collapsed_AI_classroom_data.csv")
colnames(df)
unique(df$event)
df$distilled_event <- ""
df$distilled_event[df$event == "Moving" | df$event == "Monitoring class: Moving" ] <- "Moving"
df$distilled_event[df$event == "Stopping"] <- "Stopping"
df$distilled_event[df$event == "Talking to class: ON-task" |
df$event == "Talking to student: ON-task" |
df$event == "Talking to student: OFF-task" |
df$event == "Talking to class: ON-task" |
df$event == "Talking to small group: ON-task" |
df$event == "Talking to small group: OFF-task"|
df$event == "Talking to class: OFF-task"] <- "Talking"
df$distilled_event[df$event == "Questioning: Off-Task"|
df$event == "Questioning: On-Task"]  <- "Questioning"
df$distilled_event[df$event == "Monitoring student" | df$event == "Monitoring class: Fixed"] <- "Monitoring"
df$distilled_event[df$event == "Inactive"] <- "Inactive"
df$distilled_event[df$event == "Incorrect attempt"] <- "Incorrect_attempt"
df$distilled_event[df$event == "Correct attempt"] <- "Correct_attempt"
df$distilled_event[df$event == "Raising hand"   ] <- "Raising_hand"
df$distilled_event[df$event == "Hint request"] <- "Hint_request"
df$distilled_event[df$event == "Gaming State"] <- "Gaming_State"
df$distilled_event[df$event == "Misuse State"] <- "Misuse_State"
df$distilled_event[df$event == "Idle State"] <- "Idle_State"
df$distilled_event[df$event == "Struggle State"] <- "Struggle_State"
unique(df$distilled_event)
View(df)
# 12 codes useful
View(df_locations)
View(df_locations)
View(df)
View(df_locations)
View(df)
# For setting the working directory in GitHub
#knitr::opts_knit$set(root.dir = '~/Documents/GitHub/Oulu_collab')
# Reinstallation sequence for ONA package
#remove.packages("ona")
# install.packages("ona", repos = c("https://epistemic-analytics.gitlab.io/qe-packages/ona/cran/", "https://cran.rstudio.org"))
library(rENA)
library(ona)
library(tma)
library(readxl)
library(tidyverse)
library(rstatix)
library(effsize)
# Change directory to "code/..." before push
source("./ENA_ONA_plot_fun.R")
df <- read_excel("../data/HighLevelBinaryCode.xlsx")
# I like to first make all colnames into small-caps and replace blank with "_".
names(df) <- gsub(" ", "_", tolower(names(df)))
# Take extra care about the time-related columns, you may do processing as needed.
df$start <- sapply(str_split(df$start, ":"), function(x){as.numeric(x[1])*3600 + as.numeric(x[2])*60 + as.numeric(x[3])})
df$end <- sapply(str_split(df$end, ":"), function(x){as.numeric(x[1])*3600 + as.numeric(x[2])*60 + as.numeric(x[3])})
# head(df)
unit_cols <- c("group", "participant", "phaseid")
code_cols <- names(df)[-1:-8]
eye_code_cols <- c("laptop", "peer", "other")
log_code_cols <- code_cols[-which(code_cols %in% eye_code_cols)]
meta_cols <- names(df)[1:8]
HOO_rules_model <-  tma:::rules(
group %in% UNIT$group & phaseid %in% UNIT$phaseid
)
context_model <- tma:::contexts(
x = df,
units = unit_cols,
hoo_rules = HOO_rules_model
)
ona_multimodal_tif_accum <- tma:::accumulate_contexts(
x = context_model,
codes = code_cols,
weight.by = function(x) { x },
decay.function = function(x) {
mod <- FULL_CONTEXT[RESPONSE_INDEX, ]$modality
if( mod == "Dialogue")
return(x<(FULL_CONTEXT[ROWS]$end - FULL_CONTEXT[ROWS]$start + 30))*1
if( mod == "Eye")
return(x<(FULL_CONTEXT[ROWS]$end - FULL_CONTEXT[ROWS]$start + 10))*1
else
return(0)
},
time.column = "start",
return.ena.set = FALSE,
mode.column = "modality"
)
ona_multimodal_tif_set <- model(ona_multimodal_tif_accum)
ona_multimodal_tif_gof <- ona:::correlations(ona_multimodal_tif_set)$pearson
ona_multimodal_tif_gof[[1]]
# ona_multimodal_tif_set$points is how to access ENA scores
ona_multimodal_tif_svd1 <- lm(ona_multimodal_tif_set$points$SVD1 ~ ona_multimodal_tif_set$points$phaseid) %>% summary()
ona_multimodal_tif_svd1$r.squared
source("./ENA_ONA_plot_fun.R")
research_question_name <- "ONA Multimodal Analysis"
model_name <- "ONA multimodal dataset"
make.ona.plot(ona_multimodal_tif_set,
paste0(research_question_name, model_name)
)
anova <- aov(ona_multimodal_tif_set$points$SVD1 ~ ona_multimodal_tif_set$points$phaseid)
# Run Bartlett's test, can't run Levene's test b/c we have a "quantitative explanatory variable" in our data
bartlett.test(ona_multimodal_tif_set$points$SVD1 ~ ona_multimodal_tif_set$points$phaseid)
# Extract the residuals
anova_residuals <- residuals(object = anova)
# Run Shapiro-Wilk test
shapiro.test(x = anova_residuals)
summary(anova)
pairwise.t.test(ona_multimodal_tif_set$points$SVD1, ona_multimodal_tif_set$points$phaseid, p.adjust.method = "BH")
data <- as.data.frame(ona_multimodal_tif_set$points$SVD1) %>%
mutate(points = ona_multimodal_tif_set$points$SVD1, ID = ona_multimodal_tif_set$points$phaseid) %>%
select(-"ona_multimodal_tif_set$points$SVD1")
# Effect sizes for each pairwise t test
cohens_d(data, points ~ ID)
# @param phase, an integer input of the first phase
# @param phase_next, an integer input of the next phase
# @param code1, a string input of the code to compare
# @param code2, a string input of the code to compare
# Order of input codes matters. There are lineweights for both "code1 & code2" and "code2 & code1"
# Check ONA phase plots to see directionality and infer which one to check for significance
# @return a vector with the two phase ids, the concatenated code string, the significance level, and the effect size
sigdiff_lw <- function(phase, phase_next, code1, code2) {
to_search <- str_c(code1, " & ", code2) # Concatenate code1 and code2 to get a string to search with
phaseid <- ona_multimodal_tif_set$line.weights$phaseid # Get the phase matrix from lineweights
# Make a temporary dataframe with the phase IDs and relevant line weights for inputted codes
temp_df <- as.data.frame(phaseid) %>%
mutate(line_weights = ona_multimodal_tif_set$line.weights[[to_search]])
# Make a dataframe that has the phase ID and the line weights for the first inputted phase
lineweights_phase = temp_df %>%
filter(phaseid == phase)
# Make a dataframe that has the phase ID and the line weights for the next inputted phase
lineweights_phase_next = temp_df %>%
filter(phaseid == phase_next)
# Extract the line weights
key_lw1 <- lineweights_phase$line_weights
key_lw2 <- lineweights_phase_next$line_weights
# Run a Welch t-test to see if there is a significant difference between each phase's connection between the two inputted
# Note: This t-test isn't paired because the amount of connections between code1 and code 2 (or vice versa) can be more or less in count depending on phase. For example, phase 4 has 48 connections between task_execution and low_metacognitive and
# phase 5 has 30 connections between those two codes. It isn't true that a connection occurs in phase 4 and phase 5; those connections are independent
t_test <- t.test(key_lw1, key_lw2)
# Calculate the effect size. We use cohen.d() b/c it is not dependent on sample size, whereas cohens_d() is
eff_size <- cohen.d(key_lw1, key_lw2, var.equal = FALSE)
toReturn <- tribble(
~"initial_phase", ~"next_phase", ~"codes", ~"p-value", ~"effect_size",
phase, phase_next, to_search, t_test$p.value, eff_size$estimate
)
# Return the phase IDs, the search code, the p-value, and the effect size
#toReturn <- c(phase, phase_next, to_search, t_test$p.value, eff_size$estimate)
return(toReturn)
}
# Example: Phase 4 and 5, task_execution & low_metacognitive
# We hypothesize there should be a significant difference with the ONA plot. A p-value of 0.021 w/ eff size of confirms this.
sigdiff_lw(4, 5, "task_execution", "low_metacognitive")
edge_size_multiplier = .6
edge_arrow_saturation_multiplier = 2
plot(ona_multimodal_tif_set, title = "Difference: Phase 1 (Red) vs Phase 2 (Orange)") %>%
units(
points = ona_multimodal_tif_set$points$phaseid$`1`,
points_color = "red",
show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
units(
points = ona_multimodal_tif_set$points$phaseid$`2`,
points_color = "orange",
show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
edges(
weights = (colMeans(ona_multimodal_tif_set$line.weights$phaseid$`1`) - colMeans(ona_multimodal_tif_set$line.weights$phaseid$`2`)) * 8,
edge_size_multiplier = edge_size_multiplier,
edge_arrow_saturation_multiplier = edge_arrow_saturation_multiplier,
#  node_position_multiplier = node_position_multiplier,
edge_color = c("red","orange")) %>%
nodes(
# node_size_multiplier = node_size_multiplier,
# node_position_multiplier = node_position_multiplier,
self_connection_color = c("red","orange"))
plot(ona_multimodal_tif_set, title = "Difference: Phase2 (orange) vs Phase3 (green)") %>%
units(
points = ona_multimodal_tif_set$points$phaseid$`2`,
points_color = "orange",
show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
units(
points = ona_multimodal_tif_set$points$phaseid$`3`,
points_color = "green",
show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
edges(
weights = (colMeans(ona_multimodal_tif_set$line.weights$phaseid$`2`) - colMeans(ona_multimodal_tif_set$line.weights$phaseid$`3`)) * 8,
edge_size_multiplier = edge_size_multiplier,
edge_arrow_saturation_multiplier = edge_arrow_saturation_multiplier,
# node_position_multiplier = node_position_multiplier,
edge_color = c("orange","green")) %>%
nodes(
# node_size_multiplier = node_size_multiplier,
# node_position_multiplier = node_position_multiplier,
self_connection_color = c("orange","green"))
plot(ona_multimodal_tif_set, title = "Difference: Phase 3 (green) vs Phase 4 (blue)") %>%
units(
points = ona_multimodal_tif_set$points$phaseid$`3`,
points_color = "green",
show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
units(
points = ona_multimodal_tif_set$points$phaseid$`4`,
points_color = "blue",
show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
edges(
weights = (colMeans(ona_multimodal_tif_set$line.weights$phaseid$`3`) - colMeans(ona_multimodal_tif_set$line.weights$phaseid$`4`)) * 8,
edge_size_multiplier = edge_size_multiplier,
edge_arrow_saturation_multiplier = edge_arrow_saturation_multiplier,
#node_position_multiplier = node_position_multiplier,
edge_color = c("green","blue")) %>%
nodes(
# node_size_multiplier = node_size_multiplier,
# node_position_multiplier = node_position_multiplier,
self_connection_color = c("green","blue"))
plot(ona_multimodal_tif_set, title = "Difference: Phase 4 (blue) vs Phase 5 (purple)") %>%
units(
points = ona_multimodal_tif_set$points$phaseid$`4`,
points_color = "blue",
show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
units(
points = ona_multimodal_tif_set$points$phaseid$`5`,
points_color = "purple",
show_mean = TRUE, show_points = TRUE, with_ci = TRUE) %>%
edges(
weights = (colMeans(ona_multimodal_tif_set$line.weights$phaseid$`4`) - colMeans(ona_multimodal_tif_set$line.weights$phaseid$`5`)) * 5,
edge_size_multiplier = edge_size_multiplier,
edge_arrow_saturation_multiplier = edge_arrow_saturation_multiplier,
# node_position_multiplier = node_position_multiplier,
edge_color = c("blue","purple")) %>%
nodes(
#node_size_multiplier = node_size_multiplier,
#node_position_multiplier = node_position_multiplier,
self_connection_color = c("blue","purple"))
# @param phase, an integer input of the first phase
# @param phase_next, an integer input of the next phase
# @param code1, a string input of the code to compare
# @param code2, a string input of the code to compare
# Order of input codes matters. There are lineweights for both "code1 & code2" and "code2 & code1"
# Check ONA phase plots to see directionality and infer which one to check for significance
# @return a vector with the two phase ids, the concatenated code string, the significance level, and the effect size
sigdiff_lw <- function(phase, phase_next, code1, code2) {
to_search <- str_c(code1, " & ", code2) # Concatenate code1 and code2 to get a string to search with
phaseid <- ona_multimodal_tif_set$line.weights$phaseid # Get the phase matrix from lineweights
# Make a temporary dataframe with the phase IDs and relevant line weights for inputted codes
temp_df <- as.data.frame(phaseid) %>%
mutate(line_weights = ona_multimodal_tif_set$line.weights[[to_search]])
# Make a dataframe that has the phase ID and the line weights for the first inputted phase
lineweights_phase = temp_df %>%
filter(phaseid == phase)
# Make a dataframe that has the phase ID and the line weights for the next inputted phase
lineweights_phase_next = temp_df %>%
filter(phaseid == phase_next)
# Extract the line weights
key_lw1 <- lineweights_phase$line_weights
key_lw2 <- lineweights_phase_next$line_weights
print(key_lw1)
print(key_lw2)
# Run a Welch t-test to see if there is a significant difference between each phase's connection between the two inputted
# Note: This t-test isn't paired because the amount of connections between code1 and code 2 (or vice versa) can be more or less in count depending on phase. For example, phase 4 has 48 connections between task_execution and low_metacognitive and
# phase 5 has 30 connections between those two codes. It isn't true that a connection occurs in phase 4 and phase 5; those connections are independent
t_test <- t.test(key_lw1, key_lw2)
# Calculate the effect size. We use cohen.d() b/c it is not dependent on sample size, whereas cohens_d() is
eff_size <- cohen.d(key_lw1, key_lw2, var.equal = FALSE)
toReturn <- tribble(
~"initial_phase", ~"next_phase", ~"codes", ~"p-value", ~"effect_size",
phase, phase_next, to_search, t_test$p.value, eff_size$estimate
)
# Return the phase IDs, the search code, the p-value, and the effect size
#toReturn <- c(phase, phase_next, to_search, t_test$p.value, eff_size$estimate)
return(toReturn)
}
# Example: Phase 4 and 5, task_execution & low_metacognitive
# We hypothesize there should be a significant difference with the ONA plot. A p-value of 0.021 w/ eff size of confirms this.
sigdiff_lw(4, 5, "task_execution", "low_metacognitive")
# @param phase, an integer input of the first phase
# @param phase_next, an integer input of the next phase
# @param code1, a string input of the code to compare
# @param code2, a string input of the code to compare
# Order of input codes matters. There are lineweights for both "code1 & code2" and "code2 & code1"
# Check ONA phase plots to see directionality and infer which one to check for significance
# @return a vector with the two phase ids, the concatenated code string, the significance level, and the effect size
sigdiff_lw <- function(phase, phase_next, code1, code2) {
to_search <- str_c(code1, " & ", code2) # Concatenate code1 and code2 to get a string to search with
phaseid <- ona_multimodal_tif_set$line.weights$phaseid # Get the phase matrix from lineweights
# Make a temporary dataframe with the phase IDs and relevant line weights for inputted codes
temp_df <- as.data.frame(phaseid) %>%
mutate(line_weights = ona_multimodal_tif_set$line.weights[[to_search]])
# Make a dataframe that has the phase ID and the line weights for the first inputted phase
lineweights_phase = temp_df %>%
filter(phaseid == phase)
# Make a dataframe that has the phase ID and the line weights for the next inputted phase
lineweights_phase_next = temp_df %>%
filter(phaseid == phase_next)
print(lineweights_phase)
print(lineweights_phase_next)
# Extract the line weights
key_lw1 <- lineweights_phase$line_weights
key_lw2 <- lineweights_phase_next$line_weights
# Run a Welch t-test to see if there is a significant difference between each phase's connection between the two inputted
# Note: This t-test isn't paired because the amount of connections between code1 and code 2 (or vice versa) can be more or less in count depending on phase. For example, phase 4 has 48 connections between task_execution and low_metacognitive and
# phase 5 has 30 connections between those two codes. It isn't true that a connection occurs in phase 4 and phase 5; those connections are independent
t_test <- t.test(key_lw1, key_lw2)
# Calculate the effect size. We use cohen.d() b/c it is not dependent on sample size, whereas cohens_d() is
eff_size <- cohen.d(key_lw1, key_lw2, var.equal = FALSE)
toReturn <- tribble(
~"initial_phase", ~"next_phase", ~"codes", ~"p-value", ~"effect_size",
phase, phase_next, to_search, t_test$p.value, eff_size$estimate
)
# Return the phase IDs, the search code, the p-value, and the effect size
#toReturn <- c(phase, phase_next, to_search, t_test$p.value, eff_size$estimate)
return(toReturn)
}
# Example: Phase 4 and 5, task_execution & low_metacognitive
# We hypothesize there should be a significant difference with the ONA plot. A p-value of 0.021 w/ eff size of confirms this.
sigdiff_lw(4, 5, "task_execution", "low_metacognitive")
ona_multimodal_tif_set$line.weights
# @param phase, an integer input of the first phase
# @param phase_next, an integer input of the next phase
# @param code1, a string input of the code to compare
# @param code2, a string input of the code to compare
# Order of input codes matters. There are lineweights for both "code1 & code2" and "code2 & code1"
# Check ONA phase plots to see directionality and infer which one to check for significance
# @return a vector with the two phase ids, the concatenated code string, the significance level, and the effect size
sigdiff_lw <- function(phase, phase_next, code1, code2) {
to_search <- str_c(code1, " & ", code2) # Concatenate code1 and code2 to get a string to search with
phaseid <- ona_multimodal_tif_set$line.weights$phaseid # Get the phase matrix from lineweights
# Make a temporary dataframe with the phase IDs and relevant line weights for inputted codes
temp_df <- as.data.frame(phaseid) %>%
mutate(line_weights = ona_multimodal_tif_set$line.weights[[to_search]])
print_df <- ona_multimodal_tif_set$line.weights %>%
filter(ona_multimodal_tif_set$line.weights$phaseid == 4 | ona_multimodal_tif_set$line.weights$phaseid == 5)
print(print_df)
# Make a dataframe that has the phase ID and the line weights for the first inputted phase
lineweights_phase = temp_df %>%
filter(phaseid == phase)
# Make a dataframe that has the phase ID and the line weights for the next inputted phase
lineweights_phase_next = temp_df %>%
filter(phaseid == phase_next)
#print(lineweights_phase)
#print(lineweights_phase_next)
# Extract the line weights
key_lw1 <- lineweights_phase$line_weights
key_lw2 <- lineweights_phase_next$line_weights
# Run a Welch t-test to see if there is a significant difference between each phase's connection between the two inputted
# Note: This t-test isn't paired because the amount of connections between code1 and code 2 (or vice versa) can be more or less in count depending on phase. For example, phase 4 has 48 connections between task_execution and low_metacognitive and
# phase 5 has 30 connections between those two codes. It isn't true that a connection occurs in phase 4 and phase 5; those connections are independent
t_test <- t.test(key_lw1, key_lw2)
# Calculate the effect size. We use cohen.d() b/c it is not dependent on sample size, whereas cohens_d() is
eff_size <- cohen.d(key_lw1, key_lw2, var.equal = FALSE)
toReturn <- tribble(
~"initial_phase", ~"next_phase", ~"codes", ~"p-value", ~"effect_size",
phase, phase_next, to_search, t_test$p.value, eff_size$estimate
)
# Return the phase IDs, the search code, the p-value, and the effect size
#toReturn <- c(phase, phase_next, to_search, t_test$p.value, eff_size$estimate)
return(toReturn)
}
# Example: Phase 4 and 5, task_execution & low_metacognitive
# We hypothesize there should be a significant difference with the ONA plot. A p-value of 0.021 w/ eff size of confirms this.
sigdiff_lw(4, 5, "task_execution", "low_metacognitive")
# @param phase, an integer input of the first phase
# @param phase_next, an integer input of the next phase
# @param code1, a string input of the code to compare
# @param code2, a string input of the code to compare
# Order of input codes matters. There are lineweights for both "code1 & code2" and "code2 & code1"
# Check ONA phase plots to see directionality and infer which one to check for significance
# @return a vector with the two phase ids, the concatenated code string, the significance level, and the effect size
sigdiff_lw <- function(phase, phase_next, code1, code2) {
to_search <- str_c(code1, " & ", code2) # Concatenate code1 and code2 to get a string to search with
phaseid <- ona_multimodal_tif_set$line.weights$phaseid # Get the phase matrix from lineweights
# Make a temporary dataframe with the phase IDs and relevant line weights for inputted codes
temp_df <- as.data.frame(phaseid) %>%
mutate(line_weights = ona_multimodal_tif_set$line.weights[[to_search]])
print_df <- ona_multimodal_tif_set$line.weights %>%
filter(ona_multimodal_tif_set$line.weights$phaseid == 4 | ona_multimodal_tif_set$line.weights$phaseid == 5)
View(print_df)
# Make a dataframe that has the phase ID and the line weights for the first inputted phase
lineweights_phase = temp_df %>%
filter(phaseid == phase)
# Make a dataframe that has the phase ID and the line weights for the next inputted phase
lineweights_phase_next = temp_df %>%
filter(phaseid == phase_next)
#print(lineweights_phase)
#print(lineweights_phase_next)
# Extract the line weights
key_lw1 <- lineweights_phase$line_weights
key_lw2 <- lineweights_phase_next$line_weights
# Run a Welch t-test to see if there is a significant difference between each phase's connection between the two inputted
# Note: This t-test isn't paired because the amount of connections between code1 and code 2 (or vice versa) can be more or less in count depending on phase. For example, phase 4 has 48 connections between task_execution and low_metacognitive and
# phase 5 has 30 connections between those two codes. It isn't true that a connection occurs in phase 4 and phase 5; those connections are independent
t_test <- t.test(key_lw1, key_lw2)
# Calculate the effect size. We use cohen.d() b/c it is not dependent on sample size, whereas cohens_d() is
eff_size <- cohen.d(key_lw1, key_lw2, var.equal = FALSE)
toReturn <- tribble(
~"initial_phase", ~"next_phase", ~"codes", ~"p-value", ~"effect_size",
phase, phase_next, to_search, t_test$p.value, eff_size$estimate
)
# Return the phase IDs, the search code, the p-value, and the effect size
#toReturn <- c(phase, phase_next, to_search, t_test$p.value, eff_size$estimate)
return(toReturn)
}
# Example: Phase 4 and 5, task_execution & low_metacognitive
# We hypothesize there should be a significant difference with the ONA plot. A p-value of 0.021 w/ eff size of confirms this.
sigdiff_lw(4, 5, "task_execution", "low_metacognitive")
# @param phase, an integer input of the first phase
# @param phase_next, an integer input of the next phase
# @param code1, a string input of the code to compare
# @param code2, a string input of the code to compare
# Order of input codes matters. There are lineweights for both "code1 & code2" and "code2 & code1"
# Check ONA phase plots to see directionality and infer which one to check for significance
# @return a vector with the two phase ids, the concatenated code string, the significance level, and the effect size
sigdiff_lw <- function(phase, phase_next, code1, code2) {
to_search <- str_c(code1, " & ", code2) # Concatenate code1 and code2 to get a string to search with
phaseid <- ona_multimodal_tif_set$line.weights$phaseid # Get the phase matrix from lineweights
# Make a temporary dataframe with the phase IDs and relevant line weights for inputted codes
temp_df <- as.data.frame(phaseid) %>%
mutate(line_weights = ona_multimodal_tif_set$line.weights[[to_search]])
print_df_1 <- ona_multimodal_tif_set$line.weights %>%
filter(ona_multimodal_tif_set$line.weights$phaseid == 4)
print_df_2 <- ona_multimodal_tif_set$line.weights %>%
filter(ona_multimodal_tif_set$line.weights$phaseid == 5)
View(print_df_1)
View(print_df_2)
# Make a dataframe that has the phase ID and the line weights for the first inputted phase
lineweights_phase = temp_df %>%
filter(phaseid == phase)
# Make a dataframe that has the phase ID and the line weights for the next inputted phase
lineweights_phase_next = temp_df %>%
filter(phaseid == phase_next)
#print(lineweights_phase)
#print(lineweights_phase_next)
# Extract the line weights
key_lw1 <- lineweights_phase$line_weights
key_lw2 <- lineweights_phase_next$line_weights
# Run a Welch t-test to see if there is a significant difference between each phase's connection between the two inputted
# Note: This t-test isn't paired because the amount of connections between code1 and code 2 (or vice versa) can be more or less in count depending on phase. For example, phase 4 has 48 connections between task_execution and low_metacognitive and
# phase 5 has 30 connections between those two codes. It isn't true that a connection occurs in phase 4 and phase 5; those connections are independent
t_test <- t.test(key_lw1, key_lw2)
# Calculate the effect size. We use cohen.d() b/c it is not dependent on sample size, whereas cohens_d() is
eff_size <- cohen.d(key_lw1, key_lw2, var.equal = FALSE)
toReturn <- tribble(
~"initial_phase", ~"next_phase", ~"codes", ~"p-value", ~"effect_size",
phase, phase_next, to_search, t_test$p.value, eff_size$estimate
)
# Return the phase IDs, the search code, the p-value, and the effect size
#toReturn <- c(phase, phase_next, to_search, t_test$p.value, eff_size$estimate)
return(toReturn)
}
# Example: Phase 4 and 5, task_execution & low_metacognitive
# We hypothesize there should be a significant difference with the ONA plot. A p-value of 0.021 w/ eff size of confirms this.
sigdiff_lw(4, 5, "task_execution", "low_metacognitive")
df %>% group_by(group, phaseid, participant)
df %>% group_by(group, phaseid, participant) %>% count()
View(df %>% group_by(group, phaseid, participant) )
View(df %>% group_by(group, phaseid, participant) %>% count())
ona_multimodal_tif_set$points$SVD1
ona_multimodal_tif_set$points
ona_multimodal_tif_set$points %>% group_by(phaseid) %>% count()
ona_multimodal_tif_set$points %>% group_by(phaseid)
ona_multimodal_tif_set$points %>% group_by('phaseid')
ona_multimodal_tif_set$points %>% as.data.frame() %>% group_by(phaseid)
ona_multimodal_tif_set$points$phaseid %>% as.data.frame() %>% group_by(phaseid)
ona_multimodal_tif_set$points$phaseid  %>% group_by(phaseid)
ona_multimodal_tif_set$points %>% as.data.frame() %>% group_by(ona_multimodal_tif_set$points$phaseid)
View(ona_multimodal_tif_set$points %>% as.data.frame())
ona_multimodal_tif_set$points[ona_multimodal_tif_set$points$phaseid == 4]
nrwo(ona_multimodal_tif_set$points[ona_multimodal_tif_set$points$phaseid == 4])
nrow(ona_multimodal_tif_set$points[ona_multimodal_tif_set$points$phaseid == 4])
nrow(ona_multimodal_tif_set$points[ona_multimodal_tif_set$points$phaseid == 5])
